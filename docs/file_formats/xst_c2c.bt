//------------------------------------------------
//--- 010 Editor v14.0.1 Binary Template
//
//      File: OutRun 2 Xbox / Coast2Coast XST sprite package
//   Authors: emoose
//   Version: 1.0
//   Purpose: Decode structures used in XST sprite packages
//  Category: 
// File Mask: *.xst
//  ID Bytes: 
//   History: 
//------------------------------------------------

// This mostly matches xst_lindbergh, but Xbox/C2C added a 8 byte header that gave the system memory size / video memory size used by the file
// Xbox also follows the XST headers with an XPR0, but C2C seems to have semi-obfuscated this by setting XPR0 headers to nonsense values for some reason

struct DSPDATA
{
    unsigned int scr_idx;
    unsigned short sx;
    unsigned short sy;
    unsigned short rot;
    unsigned short flip;
    float scale;
};

struct DSPTBL(int xstOffset)
{
    unsigned int nb_dspdata;
    int dspdata; // DSPDATA *
  
    local long pos = FTell();
  
    FSeek(xstOffset + dspdata);
    DSPDATA DspData[nb_dspdata];
  
    FSeek(pos);    
};

struct SCRTBL
{
    unsigned int spr_idx;
    float su; // start
    float sv;
    float eu; // end
    float ev;
    unsigned short sx; // start
    unsigned short sy;
    unsigned short ex; // end
    unsigned short ey;
};

struct SCRTBL2 // unused?
{
    unsigned int spr_idx;
    unsigned int rotate;
    float su; // start
    float sv;
    float eu; // end
    float ev;
    unsigned short sx; // start
    unsigned short sy;
    unsigned short ex; // end
    unsigned short ey;
};

struct C2CHEAD // probably not actual struct name
{
    unsigned int SysMemSize_0;
    unsigned int VidMemSize_4;
};

// In C2C these seem set to nonsense values, 1 / 2 / 3 ?
struct XPR0_Header
{
    uint32 Magic;
    uint32 TotalSize;
    uint32 HeaderSize;
};

struct XPR0_Entry
{
    uint32 common;
    uint32 data;
    uint32 lock;
    uint32 format; // todo: add bitfield struct to pull out the format values
    uint32 size;
};

struct XSTHEAD
{
    unsigned int flag;
    unsigned int tex_ofs;
    unsigned int nb_tex;
    int dummy;
    unsigned int nb_dsptbl;
    int dsptbl;
    unsigned int nb_scrtbl;
    int scrtbl;
};

struct TexData(int size)
{
    char data[size];
};

C2CHEAD MemHeader;

local long xstPos = FTell();
XSTHEAD Head;

FSeek(xstPos + Head.dsptbl);
DSPTBL DspTbl(xstPos)[Head.nb_dsptbl]<optimize=false>;

FSeek(xstPos + Head.scrtbl);
SCRTBL ScrTbl[Head.nb_scrtbl];

FSeek(xstPos + Head.tex_ofs);

XPR0_Header XPRHeader;
XPR0_Entry XPREntries[Head.nb_tex];

FSeek(MemHeader.SysMemSize_0 + 8);
local int i = 0;
local int size = 0;
for(i = 0; i < Head.nb_tex; i++)
{
    size = XPREntries[i].size;
    // "true" XPR0 seems to leave size field empty, have to work it out from the offset of the next entry (or EOF)
    if (size == 0 && i+1 < Head.nb_tex)
        size = XPREntries[i+1].data - XPREntries[i].data;
    if (size == 0)
        size = FileSize() - FTell();
    TexData Texture(size)<optimize=false>;    
}
